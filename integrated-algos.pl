#########################################################################################
# Description: 	This file generates fault statistics from the faults					#
#			   	file generated by HOPE for a given benchmark. The						#
#				output is a new bench file consisting of Quaded and Duplicated logic	#
#																						#
# USAGE: perl circuit-stats.pl [Faults File] [Error Threshold]							#
#		[Faults File] = log file generated by HOPE.										#
#		[Error Threshold] =  reports only errors >= Threshold.							#
# 																						#
# Author: Ahmad Tariq Sheikh.															#
#																						#
# Date: October 26, 2013																#
#																						#
#########################################################################################

#!/usr/bin/perl -w

use warnings;
use Cwd;
use Time::HiRes;
use File::Basename;
use Data::Dumper qw(Dumper); 
use Storable qw(retrieve nstore dclone);
use Clone qw(clone);
use Sort::Naturally;
#---------------------

sub readBenchFile {
	# print "\tReading $inputFile.bench file ... \n";
	# my $start_time = [Time::HiRes::gettimeofday()];
	
	$benchFile = "$inputFile.bench";
	
	open (INPUT_FILE, $benchFile) or die $!;
	
	$currentPO = ();
	$poIndexCounter = 0;
	my %tempCompleteGates = ();	
	%gateBelongings = (); 
	@primaryOutputs = ();
	@primaryInputs = ();
	@inter_IO_Gates = ();
	@allGates = ();
	@multiFanOuts = ();
	%poIndices = ();
	%inputs = ();
	%fanouts = ();
	%completeGates = ();
	%gatesCounter = ();
	
		
	while(<INPUT_FILE>) {
		if ($_ =~ m/INPUT(.*)/) {		
			if ($1 =~ m/(\w+)/) {
				push (@primaryInputs, $1);	
			}
		}
		elsif ($_ =~ m/OUTPUT(.*)/) {
			if ($1 =~ m/(\w+)/) {
				push (@primaryOutputs, $1);					
			}
		}
		elsif ($_ =~ /#/ or $_ =~ /^\s/) {
			next;
		}		
		elsif ($_ =~ m/=/) {			
			
			my @gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);
				
						
			# print "@gateList,  Length = ", scalar @gateList, ", GN: $gateName[0],  POINDEX: $poIndexCounter\n";			
			# $cin=getc(STDIN); exit;
			
			if (grep {$_ eq $gateList[0]} @primaryOutputs) {
				$currentPO = shift(@primaryOutputs);
				push @primaryOutputs, $currentPO;
				$poIndices{$gateList[0]} = $poIndexCounter;
			}
			else {
				$currentPO = $primaryOutputs[0];
			}
						
			$gateBelongings{$gateList[0]} = $currentPO;
			
			#---------------------------------------------------
			# Create an output to input and input to output MAP
			#---------------------------------------------------
			my $connections = ();
			for my $i (1..scalar @gateList-1) {				
				$connections .= "$gateList[$i]";	
				if ((scalar @gateList > 1) && ($i < scalar @gateList-1)) {
					$connections .= "-";
				}
				
				if (exists($fanouts{$gateList[$i]})) {				
					$temp = $fanouts{$gateList[$i]};
					$fanouts{$gateList[$i]} = $temp."-".$gateList[0];
				}
				else {
					$fanouts{$gateList[$i]} = $gateList[0];	
				}				
			}
			$inputs{$gateList[0]} = $gateName[0]."-".$connections;	

			# if ($gateName[0] eq "NOT") {
				# if (grep {$_ eq $connections} @primaryInputs) {
					# $invertedInputs = $gateList[0];
				# }
			# }			
			
			push @inter_IO_Gates, $gateList[0];				
			#-------------------------------------------------
			
			for my $i(0..scalar @gateList - 1) {			
				if (!(exists($tempCompleteGates{$gateList[$i]}))) {				
					if ($i == 0) {					
						$tempCompleteGates{$gateList[$i]} = 0;	
						$gatesCounter{$gateList[$i]} = 0;
						$completeGates{$gateList[$i]} = 0;	
					}
					else {					
						$tempCompleteGates{$gateList[$i]} = $gateList[0];	
						$gatesCounter{$gateList[$i]} = 1;
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";	
					}
				}
				else {				
					$gatesCounter{$gateList[$i]}++;										
					if ($gatesCounter{$gateList[$i]} >= 2) {							
						$tempCompleteGates{"$gateList[$i]->$gateList[0]"} = $gateList[0];
						$tempCompleteGates{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = $tempCompleteGates{$gateList[$i]};												
						$gatesCounter{"$gateList[$i]->$gateList[0]"} = 0;
						$gatesCounter{"$gateList[$i]->$tempCompleteGates{$gateList[$i]}"} = 0;						
						
						if ($completeGates{$gateList[$i]} eq 0) {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";	
						}
						else {
							$completeGates{"$gateList[$i]->$gateList[0]"} = "$gateName[0]-$gateList[0]";						
							@previousLine = split('-', $completeGates{$gateList[$i]});							
							$completeGates{"$gateList[$i]->$previousLine[1]"} = "$previousLine[0]-$previousLine[1]";					
							$completeGates{$gateList[$i]} = 0;
						}
					}
					else {	
						$tempCompleteGates{$gateList[$i]} = $gateList[0];							
						$completeGates{$gateList[$i]} = "$gateName[0]-$gateList[0]";													
					}
				}
			}					
			$poIndexCounter++;
		}		
	}	
	close(INPUT_FILE);	
	
	
	
	####################################################
	# Fanout Counter
	####################################################
	foreach my $node (%fanouts) {	
		
		if (exists($fanouts{$node})) {		
			# print "Node = $node, Fanouts = $fanouts{$node} \n";
			@row = split("-", $fanouts{$node});
			$fanoutCounter{$node} = scalar @row;
			if ($fanoutCounter{$node} > 1) { # and ($node =~ m/g/)) {
				push @multiFanOuts, $node;
			}			
		}
	}
	
	
	# my $run_time = Time::HiRes::tv_interval($start_time);
	# print "\tTime taken Reading Bench file = $run_time sec.\n\n";	
	
	@allGates = @{ dclone(\@inter_IO_Gates) };	
	@inter_IO_Gates = nsort @inter_IO_Gates;	
}
#######################################################

sub readFaultsFile {		
	print "\tReading $inputFile.fault file ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	open (FILE, "$inputFile.fault") or die $!;		

	while (<FILE>) {
		chomp;
		if ($_ =~ m/\*/) {	
			$flag = 1;
			next;			
		}
		elsif($_ =~ m/Number of primary inputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryInputs = $1;
			}			
		}
		elsif($_ =~ m/Number of primary outputs(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfPrimaryOutputs = $1;
			}			
		}
		elsif($_ =~ m/Number of combinational gates(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCombGates = $1;
			}			
		}
		elsif($_ =~ m/Number of flip-flops(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfFF = $1;
			}			
		}
		elsif($_ =~ m/Level of the circuit(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfLevels = $1;
			}			
		}
		elsif($_ =~ m/Number of test patterns applied(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfTestVectors = $1;
			}			
		}
		elsif($_ =~ m/Number of collapsed faults(.*)/) {
			if ($1 =~ m/(\d+)/) 	{
				$numberOfCollapsedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of detected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfDetectedFaults = $1;
			}			
		}
		elsif($_ =~ m/Number of undetected faults(.*)/) {
			if ($1 =~ m/(\d+)/) {
				$numberOfUndetectedFaults = $1;				
			}			
		}
		elsif($_ =~ m/Fault coverage(.*)/) {
			if ($1 =~ m/(\d+\.\d+)/) {
				$faultCoverage = $1;
			}			
		}
		elsif (!$flag) {
			$row = [ split ];
			if (@$row[0] =~ m/test/) {					
				push @testVectors, @$row[2];
			}
			else {	
								
				if (!(exists($listOfGates{@$row[0]}))) {
					$listOfGates{@$row[0]} = 0;	
				}
				
				if (@$row[1] =~ m/(\d)/) {
					$faultValue =	$1;	
				}	
				
				# print "ROW: @$row[0], @$row[1], Value: $faultValue\n"; $cin=getc(STDIN);
				
				if ($faultValue == 1) {										
					if (exists($circuitFaults_original_1{@$row[0]})) {
						$circuitFaults_original_1{@$row[0]}++;	
					}
					else {
						$circuitFaults_original_1{@$row[0]} = 1;	
					}
				}
				else {
					if (exists($circuitFaults_original_0{@$row[0]})) {
						$circuitFaults_original_0{@$row[0]}++;	
					}
					else {
						$circuitFaults_original_0{@$row[0]} = 1;	
					}
				}					
			}
		}		
	}
	close(FILE);	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print  "\tTime taken Reading Faults file = $run_time sec.\n\n";
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_original_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_original_1;
	# print Dumper \%listOfGates;exit;
}
#######################################################

sub findEquivFaults {
	print "\tFinding Equivalent Faults ... \n";
	my $start_time = [Time::HiRes::gettimeofday()];
	
	%circuitFaults_0 = %{ clone (\%circuitFaults_original_0) };
	%circuitFaults_1 = %{ clone (\%circuitFaults_original_1) };
	
	# foreach (sort keys %gatesCounter) {
		# print "$_, ",$gatesCounter{$_}, " \n";
	# }
	# exit;
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_1; exit;	

	#insert the non-existing faults in the hash table
	foreach $k (@inter_IO_Gates) {	
		if (!(exists($circuitFaults_0{$k}))) {
			$circuitFaults_0{$k} = 0;	
			$circuitFaults_original_0{$k} = 0;
		}
		if (!(exists($circuitFaults_1{$k}))) {
			$circuitFaults_1{$k} = 0;	
			$circuitFaults_original_1{$k} = 0;
		}		
	}	
	
	foreach $k (@primaryInputs) {	
		if (!(exists($circuitFaults_0{$k}))) {
			$circuitFaults_0{$k} = 0;	
			$circuitFaults_original_0{$k} = 0;
		}
		if (!(exists($circuitFaults_1{$k}))) {
			$circuitFaults_1{$k} = 0;	
			$circuitFaults_original_1{$k} = 0;
		}		
	}
			
	foreach $gate (@inter_IO_Gates) {		
		
		@FO = split('-', $inputs{$gate});		

		# print "Gate: $gate, @FO\n";
		# $cin=getc(STDIN);
		
		foreach $ii (1..scalar @FO - 1) {			
		
			if (($FO[0] =~ m/NAND/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_1{$gate};	
			}
			elsif (($FO[0] =~ m/AND/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_0{$gate};	
			}
			elsif (($FO[0] =~ m/NOT/) and ($gatesCounter{$FO[$ii]} < 2)) {					
				$circuitFaults_0{$FO[$ii]} = $circuitFaults_1{$gate};					
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_0{$gate};								
			}			
			if (($FO[0] =~ m/NOR/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_0{$gate};		}
				
			elsif (($FO[0] =~ m/OR/) and ($gatesCounter{$FO[$ii]} < 2)) {
				$circuitFaults_1{$FO[$ii]} = $circuitFaults_1{$gate};	
			}
		}
	}
	my $run_time = Time::HiRes::tv_interval($start_time);

	print "\tTime taken finding Equivalent faults = $run_time sec.\n";		
	nstore \%circuitFaults_0, $inputFile."_sa0.prob";
	nstore \%circuitFaults_1, $inputFile."_sa1.prob";		
	
	# print "sa0 \n";
	# print Dumper \%circuitFaults_0;
	# print "sa1 \n";
	# print Dumper \%circuitFaults_1; exit;	
}
#######################################################

sub selectionAlgorithmWithPOFSUpdate_ONLY {
	
	my $thValue = $_[0];
			
	my @orderedGates = ();
	my @sensitiveNodes = ();
	my @processedNodes = ();
	my @IOs = ();
	my %outBenchFile = ();
	my %probOfFailure = ();
	my %probOfFailure_COPY = ();
	my %detectionProb = ();
	my %strikeProb = ();
	my %protType = ();	
	my %gateConts_0 = ();
	my %gateConts_1 = ();
	my %currentCircuitGateAreas = ();	
	my %nodeAreas = ();
	my $currentArea = 0;
	my $currentNT = 0;
	my $targetArea = 0;
	
	my $verbosity = 0;
		
	%ipp = %{retrieve($inputFile.'.ipp')};
	%tech = %{retrieve('130nm.pf')};
	# print Dumper \%ipp;
	
	my @ths = qw ($thValue);
	
	my $start_time = [Time::HiRes::gettimeofday()];	
	
	$nmosDrainArea = 0.26;
	$pmosDrainArea = 0.52;
	
	################################################
	# Get Area of current Circuit
	###############################################
	system ("perl bench_to_spice_130nm.pl $inputFile 1");
	open(IN,"area.sp") || die " Cannot open input file area.sp \n";
	$circuitArea=0;	# area of circuit
	while(<IN>){
		$circuitArea = $_;
	}
	close(IN);
	system ("del area.sp");
	system ("del $inputFile.sp");
		
	#############################################################
	#	Read the Propagation Stats file of current circuit.		#
	#############################################################
	my %currentCircuitPropFailureProbs = ();
	$propFile = $inputFile.".prop";
	
	open (PROP_IN, $propFile) or die $!;
	while(<PROP_IN>) {
		chomp;
		@row = split('=>', $_);
		$currentCircuitPropFailureProbs{$row[0]} = $row[1];		
	}
	close(PROP_IN);	
	#############################################################
	
	#---------------------------------------------------#
	#	Save each gate in the circuit along with 		#
	#   the prob. of failure of each transistor			# 
	#	in HASH structure. 								#
	#---------------------------------------------------#
	open (INPUT_FILE, $benchFile) or die $!;	
	while (<INPUT_FILE>) {	
		if (/=/) {				
			my @gateList = split(" = ", $_);
			$gateList[1] = "= ".$gateList[1];			
						
			$currentGate = $gateList[0];				
			$outBenchFile{$currentGate} = $gateList[1];		
			push @orderedGates, $currentGate;
			
			$protType{$currentGate} = 0; #Initialize the protection type of each senstive gate to 0			
			
			#-----------------------------------------------------------#
			#	Compute Probability of failure of each transistor of	#
			#	the current selected gate.								#
			#-----------------------------------------------------------#
			
			#-------------------------------------------------
			#Generate the remaining parts of final bench file
			#-------------------------------------------------			
			@gateList = ($_ =~ m/(\w+)/g);				
			$gateName[0] = $gateList[1];			
			@gateList = ($gateList[0], @gateList[2..$#gateList]);	

			$currentGate = $gateList[0];	
			@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.	
			$gateName = $inputs[0]; 	
			
			$currentCircuitGateAreas{$currentGate} = $gateArea_130nm{$gateName.(scalar @inputs-1)};
			
			my $errorType = -1;
			my $gateType = ();
						
			$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
			$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);			
								
			# process the Gates			
			my $nType = 0;
			my $pType = 0;
			my $nmos = 0;
			my $pmos = 0;			
				
			#iterate through all the N-type and P-Type transistors.
			for ($ii = 1; $ii < scalar @inputs; $ii++) {
				$nmos = "N".$ii;
				$pmos = "P".$ii;					
				
				#Compute gate controllability from the .ipp file, only once for each gate
				if ($ii==1) {
				
					#FOR NMOS
					# Read the generic failed vectors for N1
					@failedVectors = ();
					$nmos1 = $gateName.(scalar @inputs - 1)."-N$ii";						
					
					for $vector ( keys %{ $tech{$nmos1} } ) {
						push @failedVectors, $vector;						
					}										
				
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
					
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 							
					}
					$gateConts_1{$currentGate} = $freq;
						
					#FOR PMOS
					# Read the generic failed vectors for P-Type
					@failedVectors = ();	
					$pmos1 = $gateName.(scalar @inputs - 1)."-P$ii";	
										
					for $vector ( keys %{ $tech{$pmos1} } ) {
						push @failedVectors, $vector;						
					}					
					
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$currentGate} } ) {
						push @currentFailedVectors, $vector;						
					}				
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
				
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					$gateConts_0{$currentGate} = $freq;
					
					if ($gateConts_1{$currentGate}==0) {	$gateConts_1{$currentGate} = 1;	}
					if ($gateConts_0{$currentGate}==0) {	$gateConts_0{$currentGate} = 1;	}					
				}				
								
				$currentNode_N = $currentGate."-$nmos";
				$currentNode_P = $currentGate."-$pmos";
				
				if ($currentCircuitPropFailureProbs{$currentNode_N}*$sa0 > 0) {
					$detectionProb{$currentNode_N}	=	$currentCircuitPropFailureProbs{$currentNode_N}*$sa0/$gateConts_1{$currentGate};
					$strikeProb{$currentNode_N} 	=	$nmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
					$probOfFailure{$currentNode_N}	= 	$detectionProb{$currentNode_N}*$strikeProb{$currentNode_N};					
				}
				else {
					$detectionProb{$currentNode_N}	= 0;					
					$probOfFailure{$currentNode_N} = 0;						
					$nodeAreas{$currentNode_N} = $nmosDrainArea;
				}
								
				if ($currentCircuitPropFailureProbs{$currentNode_P}*$sa1 > 0) {
					$detectionProb{$currentNode_P}	=	$currentCircuitPropFailureProbs{$currentNode_P}*$sa1/$gateConts_0{$currentGate};
					$strikeProb{$currentNode_P} 	=	$pmosDrainArea/$circuitArea;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
					$probOfFailure{$currentNode_P}	= 	$detectionProb{$currentNode_P}*$strikeProb{$currentNode_P};					
				}
				else {
					$detectionProb{$currentNode_P}	= 0;
					$probOfFailure{$currentNode_P}  = 0;
					$nodeAreas{$currentNode_P} = $pmosDrainArea;
				}								
				# if ($currentGate eq "IMP8") {
					# print "Current Gate = $currentGate, inputs = @inputs, $nmos1 Area = $nmosDrainArea, $pmos1 Area = $pmosDrainArea, Total Area = $circuitArea\n";
					# print "Node = $currentNode_N, Prob SA0 = $sa0, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_N}\n";
					# print "$currentNode_N: DET = $detectionProb{$currentNode_N}, Strike = $strikeProb{$currentNode_N},  POF $nmos = $probOfFailure{$currentNode_N}\n\n";					
					# print "Node = $currentNode_P, Prob SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, IPP = $currentCircuitPropFailureProbs{$currentNode_P}\n";
					# print "$currentNode_P: DET = $detectionProb{$currentNode_P}, Strike = $strikeProb{$currentNode_P},  POF $pmos = $probOfFailure{$currentNode_P}\n\n";			
				# }	

				$gatePOF{$currentGate} += $probOfFailure{$currentNode_N};
				$gatePOF{$currentGate} += $probOfFailure{$currentNode_P};				
			}					
		}		
		elsif ($_ =~ /INPUT|OUTPUT/) {
			push @IOs, $_;
		}
	} #End of Main while loop
	close(INPUT_FILE);
	#############################################################
		
	open (LOG, ">$inputFile.$thValue.log") or die $!;
	
	#Sort the gates according to their prob. of failure
	@sensitiveNodes = ();
	$POF = 0;
	@outputsOnly = ();
	foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {							
		 push @sensitiveNodes, $name;	
		$POF += $probOfFailure{$name};	

		$gg = (split ("-", $name))[0];
		if ( (grep {$_ eq $gg} @primaryOutputs) or ($gg =~ m/_3$/) ) {		
			push @outputsOnly, $name;
		}
		# print "N = $name, POF = $probOfFailure{$name}\n";
	}	
	$totalNodes = scalar @sensitiveNodes;
	$circuitArea = sprintf("%0.3f", $circuitArea);		
	
	# print Dumper \%gatePOF;
	
	printf "==>Initial POF = %0.4f, Area = $circuitArea, TH = %0.4f, Total Nodes = $totalNodes\n", $POF*100, $thValue*100;		
	# print "==>Area = $circuitArea, Total Nodes = $totalNodes\n";		
	%POF_ORIGINAL =  %{ dclone(\%probOfFailure) }; 
	exit;
	#############################################################
   

	#-------------------------------------------------------------#				
	
	print (LOG "************************************\n");  
	print (LOG "PROCESSING $inputFile ...\n\n");  
	printf (LOG "==>POF = %0.4f, Area = %0.4f, Total Nodes = %d, TH = %0.4f\n",$POF*100, $circuitArea, scalar @sensitiveNodes, $thValue*100);
	#************************************************************************
	#	Protection Code Starts from here
	#************************************************************************
	@allNodes = @{ dclone(\@sensitiveNodes) }; 
	%areaOH = ();
		
	# $crg = "g212-P1";		
	
	$currentNode = shift(@outputsOnly); 
	$currentNode = shift(@sensitiveNodes); #Comment this if required to protect DMR voter only.
	
	$flag = 0;	
	$currentNodePOF = 0;		
	@sensitiveNodes = ();
	
	
	# while ($probOfFailure{$currentNode} >= $thValue) {											
	while ($POF >= $thValue and defined($currentNode)) {											
		
		if (!(grep {$_ eq $currentNode} @sensitiveNodes)) {
			push @sensitiveNodes, $currentNode;
		}
					
		@row = split("-", $currentNode);				
		$currentGate = $row[0];
		$currentType = $row[1]; # i.e. nmos or pmos		
		@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.										
		$gateName = $inputs[0]; 			
		
		my @pNodes = getProcessedNodes($currentNode, $gateName,  scalar @inputs - 1);
		foreach $ll (@pNodes) {
			if (!(grep {$_ eq $ll} @processedNodes)) {
				push @processedNodes, $ll;	
			}
		}
		
		# print "CN = $currentNode\n"; $cin=getc(STDIN);exit;
					
		if ($gateName eq "NAND") {
			$protectionType = getProtectionTypeNAND_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);						
		}
		elsif ($gateName eq "NOR") {
			$protectionType = getProtectionTypeNOR_NORMAL($protType{$currentGate}, $currentType, scalar @inputs - 1);		
		}		
		elsif ($gateName eq "NOT") {
			$protectionType = getProtectionTypeNOT($protType{$currentGate}, $currentType, scalar @inputs - 1);									
		}		
		
		# protecting the type e.g., NAND21, NAND32, NAND43 etc.
		$redundancyModel	=	$gateName.(scalar @inputs - 1).$protectionType;		 

		#Update Circuit Area
		$newArea = sprintf("%0.3f", $gateArea_130nm{$redundancyModel});
		$oldArea = sprintf("%0.3f", $currentCircuitGateAreas{$currentGate});
		$overHead = sprintf("%0.3f", $newArea - $oldArea);				
		$circuitArea += sprintf("%0.3f", $overHead);
		$protType{$currentGate} = $protectionType;			
		$currentCircuitGateAreas{$currentGate} +=  $overHead;
		$areaOH{$currentNode} = $overHead;
		$currentNodePOF = $probOfFailure{$currentNode};
		
		# if ($flag==1) {
			# print "CN: $currentNode, Gate Area = $currentCircuitGateAreas{$currentGate}, New AREA = $gateArea_130nm{$redundancyModel}, OH = $overHead, OA = $oldArea\n";
		# }
			
		@nodesToUpdate = ();
		if ($inputs[0] eq "NAND" or $inputs[0] eq "NOR") {
			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-N$kk";					
			}			
			for $kk (1..scalar @inputs -1) {
				push @nodesToUpdate, $currentGate."-P$kk";					
			}			
		}			
		elsif ($inputs[0] eq "NOT") {				
			push @nodesToUpdate, $currentGate."-N1";
			push @nodesToUpdate, $currentGate."-P1";						
		}
		
		# if ($currentNode eq "g212-P1") {
			# print "\n*******************************************************************************\n";
			# print "Protection Algorithm starting to protect $currentNode\n";
			# print "*******************************************************************************\n";
			# print "====>Current Node = $currentNode, POF = ".($probOfFailure{$currentNode}*100).", Area = $circuitArea, AREA OH = $areaOH{$currentNode}, Prev Area = ",($circuitArea-$overHead),", Prot Type = $protType{$currentGate}\n\n";		
		# } 
		
		# Iterate through the transistors list to update their POFs	
		foreach my $node (@allNodes) {

			@failedVectors = ();	

			@row = split("-", $node);				
			$CG = $row[0];
			$cType = $row[1]; # i.e. nmos or pmos	
									
			if (grep {$_ eq $node} @nodesToUpdate) {
				if ($protectionType == 20) { # FULLY PROTECTED CASE, make POFs of transistors of $currentGate to zero
					$probOfFailure{$node}	= 	0;	
					$detectionProb{$node} = 	0;
					$nodeAreas{$node} = $transArea_130nm{$redundancyModel."-$cType"};
				}
				else {
					$trans = $redundancyModel."-$cType";					
					
					for $vector ( keys %{ $tech{$trans} } ) {
						push @failedVectors, $vector;						
					}					
			
					# Read the failed vectors for current gate in the current circuit
					@currentFailedVectors = ();
					for $vector ( keys %{ $ipp{$CG} } ) {
						push @currentFailedVectors, $vector;						
					}
					
					@isect = intersect(@failedVectors, @currentFailedVectors);
													
					$freq=0;
					foreach $value (@isect) {							
						$freq += $ipp{$currentGate}{$value}; 
					}
					
					$sa0 = sprintf("%.8f", $circuitFaults_0{$currentGate}/$numberOfTestVectors);
					$sa1 = sprintf("%.8f", $circuitFaults_1{$currentGate}/$numberOfTestVectors);									
						
					$drainArea = $transArea_130nm{$trans};	
					$nodeAreas{$node} = $drainArea;
									
					$gateContProb = 0;
					$stuckAtProb = 0;
					
					if ($cType =~ m/N/i) {
						$gateContProb = $gateConts_1{$CG};
						$stuckAtProb = $sa0;
					}
					else {
						$gateContProb = $gateConts_0{$CG};
						$stuckAtProb = $sa1;
					}
					
					$detectionProb{$node}	=	($freq*$stuckAtProb)/$gateContProb;
					$strikeProb{$node} 	=	$drainArea/$circuitArea;
					$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				}
				# if (($currentNode eq "g212-P1" and $flag==1) or $verbosity ==1) {
					# print "Node = $node, protType = $protectionType,  CG = $currentGate, $trans Area = $drainArea, Total Area = $circuitArea\n";
					# print "Prob SA0 = $sa0, SA1 = $sa1, PC0 = $gateConts_0{$currentGate}, PC1 = $gateConts_1{$currentGate}, IPP = $currentCircuitPropFailureProbs{$node}\n";		
					# print "Failed Vecs. = @failedVectors\n";
					# print "Current IPP = @currentFailedVectors\nCommon = @isect\n";						
					# print "Node = $node: FREQ=$freq, DET = ",$detectionProb{$node}," HIT = ",$strikeProb{$node}," Trans-Area = $drainArea, POF $node = ",$probOfFailure{$node}*100,"\n\n";
				# }		
			}
			else {
				$drainArea = $nodeAreas{$node};				
				$strikeProb{$node} 	=	$drainArea/$circuitArea;					
				$probOfFailure{$node}	= 	$detectionProb{$node}*$strikeProb{$node};					
				
				# if ($currentNode eq "v" or $verbosity ==1) {
					# print "::Node = $node: DET = $detectionProb{$node}, HIT = $strikeProb{$node}, Trans-Area = $drainArea, POF $node = $probOfFailure{$node}\n";	
				# }
			}			
		}								
		###############################################################################
	
		$NEWPOF = 0;
		foreach my $name (@allNodes) {				
			$NEWPOF += $probOfFailure{$name};										
		}	 	
		
		# printf (LOG "POF = %0.6f\n", $NEWPOF*100);			
		
		printf (LOG ">CIRC POF= %0.4f, Area= %.4f, CN= $currentNode, Orig. POF= %0.6f, POF= %0.6f, Gain= %0.6f, Net Gain= %0.6f, PT= $protType{$currentGate}, OH= $areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100), ($NEWPOF-$POF)*100, ($NEWPOF-$POF)/$areaOH{$currentNode}*100 );
		
		printf (">CIRC POF=%0.4f, Area=%.4f, CN=$currentNode, Orig. POF=%0.6f, POF= %0.6f, PT=$protType{$currentGate}, OH=$areaOH{$currentNode}, GN=".($gateName.scalar @inputs-1)."\n", $NEWPOF*100, $circuitArea, ($POF_ORIGINAL{$currentNode}*100), ($currentNodePOF*100) );			
				
		@temp = ();
		foreach my $name (sort { $probOfFailure{$b} <=> $probOfFailure{$a} or $a cmp $b } keys %probOfFailure) {
			if ($probOfFailure{$name} > 0 and !(grep {$_ eq $name} @sensitiveNodes)) {
				
				#Uncomment following 4 lines if required to protect DMR voter only.
				# $gg = (split ("-", $name))[0];				
				# if ( (grep {$_ eq $gg} @primaryOutputs) or ($gg =~ m/_3$/) ) {
					# push @temp, $name;	
				# }
				
				#Uncomment the following line if required to apply STR to the whole circuit.
				push @temp, $name; 	
			}
			# print "Node = $name, POF = $probOfFailure{$name}\n";
		}		
		
		$currentNode = shift(@temp);	
		$POF = $NEWPOF;		
		
		# print "==>Next Node = $currentNode, POF = $probOfFailure{$currentNode}\n";
		
		
		###################################################################################
			
		$currentTh = $thValue;
		# if ( $probOfFailure{$currentNode} < $thValue ) { 
		if ( $POF < $thValue or !defined($currentNode)) { 
			
			#------------------------------------------------------	
			#	Writing the final bench file by iterating through
			#	all the gates and based on their nType and pType
			#	variable values, apply suitable protection.
			#------------------------------------------------------	
			
			$newBenchFile = $inputFile."R_".$currentTh.".bench";	
			open (OUTPUT_Bench, ">$newBenchFile") or die $!;
			print OUTPUT_Bench "#Protection with Threshold of  ".((1-$currentTh)*100)."%\n";
			print OUTPUT_Bench "\n";
			print OUTPUT_Bench @IOs;
			print OUTPUT_Bench "\n";
			
			foreach $currentGate (@orderedGates) {
			
				@inputs = split("-", $inputs{$currentGate});	#inputs to the current gate.			
				$gateName = $inputs[0]; 	 
				
				if (($protType{$currentGate} == 20 )) { # or (grep {$_ eq $currentGate} @primaryOutputs)) {						
					print OUTPUT_Bench "$currentGate = D".$gateName."(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}
				elsif (($protType{$currentGate} > 0 and $protType{$currentGate} < 9)) {
					print OUTPUT_Bench "$currentGate = $inputs[0]".(scalar @inputs -1)."$protType{$currentGate}(";								
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs -1) {
							print OUTPUT_Bench "$inputs[$ii])\n";	
						}
						else {
							print OUTPUT_Bench "$inputs[$ii], ";	
						}
					}					
				}		
				elsif ($protType{$currentGate} == 0 ) { 
					print OUTPUT_Bench "$currentGate = $gateName(";							
					for ($ii = 1; $ii < scalar @inputs; $ii++) {					
						if ($ii  == scalar @inputs - 1)	
						{	print OUTPUT_Bench "$inputs[$ii])\n";	}
						else
						{	print OUTPUT_Bench "$inputs[$ii], ";	}											
					}											
				}		
				else {
					print OUTPUT_Bench $_;	
				}	
				
				if (grep $_ eq $currentGate, @primaryOutputs) {
				print OUTPUT_Bench "\n";
				}
			}
			
			print OUTPUT_Bench "END\n";
			close(OUTPUT_Bench);	
			#-------------------------------------------------------------
			
			$currentTh = shift(@ths);
		}
	}
	
	my $run_time = Time::HiRes::tv_interval($start_time);
	print "\tTime taken to create Bench File = $run_time sec.\n";	
	print LOG "\n\tTime taken = $run_time sec.\n";	
	
	open (OUT, ">>area.txt") or die $!;	
	print OUT "$circuitArea \n"; close(OUT);	
	close(LOG); 
	
	# $POF = 0;
	# foreach my $name (@allNodes) {				
		# printf(LOG "> CN = $name, POF = $probOfFailure{$name}\n");										
		# print "$name: $probOfFailure{$name}\n";
	# }
	# printf(LOG "\n\nFINAL POF = $POF\n");
	
}
#######################################################

#-----------------------------------------------
#		Main Program
#-----------------------------------------------

$cwd = getcwd; #get Current Working Directory
$inputFile = $ARGV[0]; #faults file generated by HOPE
$inputs  = $ARGV[1];  #error threshold or area overhead
# $threshold2  = $ARGV[2];  #error threshold or area overhead

#-----------------------------------------------
#		Variables Initialization
#-----------------------------------------------
%circuitFaults_1 = ();
%circuitFaults_0 = ();
%circuitFaults_original_1 = ();
%circuitFaults_original_0 = ();
$numberOfPrimaryInputs = 0;
$numberOfPrimaryOutputs = 0;
$numberOfCombGates = 0;
$numberOfFF = 0;
$numberOfLevels = 0;
$numberOfCollapsedFaults = 0;
$numberOfDetectedFaults = 0;
$numberOfUndetectedFaults = 0;

########################################################
#The number of test vectors used for actual simulations 
if ($numberOfPrimaryInputs > 20) {
	$numberOfTestVectors = 1000000;	
}
else {
	$numberOfTestVectors = 2**$numberOfPrimaryInputs;	
}
########################################################

$faultCoverage = 0;
@testVectors = ();
@primaryOutputs = ();
@primaryInputs = ();
@inter_IO_Gates = ();
%listOfGates = ();
%completeGates = ();
%inputs = ();
%fanouts = ();
%gatesCounter = ();
%gatePOF = ();

#-----------------------------------------------
{
%gateArea_130nm = (	'NOT1'		=> '0.780',
				'NOT11'		=> '2.756',
				'NOT12'		=> '1.560',
				'NOT120'	=> '3.536',
				'NAND2'		=> '1.560',
				'NAND21'	=> '3.536',
				'NAND22'	=> '5.512',
				'NAND23'	=> '4.264',
				'NAND24'	=> '6.240',
				'NAND220'	=> '8.216',
				'NAND3'		=> '2.340',
				'NAND31'	=> '4.316',
				'NAND32'	=> '6.292',
				'NAND33'	=> '8.268',
				'NAND34'	=> '7.956',
				'NAND35'	=> '9.932',
				'NAND36'	=> '11.908',
				'NAND320'	=> '13.884',
				'NAND4'		=> '3.120',
				'NAND41'	=> '5.096',
				'NAND42'	=> '7.072',
				'NAND43'	=> '9.048',
				'NAND44'	=> '11.024',
				'NAND45'	=> '12.688',
				'NAND46'	=> '14.664',
				'NAND47'	=> '16.640',
				'NAND48'	=> '18.616',
				'NAND420'	=> '20.592',			
				'NOR2'		=> '1.560',
				'NOR21'		=> '2.340',
				'NOR22'		=> '3.120',
				'NOR23'		=> '9.672',
				'NOR24'		=> '10.452',
				'NOR220'	=> '11.232',
				'NOR3'		=> '2.340',
				'NOR31'		=> '3.120',
				'NOR32'		=> '3.900',
				'NOR33'		=> '4.680',
				'NOR34'		=> '20.124',
				'NOR35'		=> '20.904',
				'NOR36'		=> '21.684',
				'NOR320'	=> '22.464',
				'NOR4'		=> '3.120',
				'NOR41'		=> '3.900',
				'NOR42'		=> '4.680',
				'NOR43'		=> '5.460',
				'NOR44'		=> '6.240',
				'NOR45'		=> '32.240',
				'NOR46'		=> '33.020',
				'NOR47'		=> '33.800',
				'NOR48'		=> '34.580',
				'NOR420'	=> '35.360'
			);					
}


{
%transArea_130nm = ('NOT11-N1'	=>	'0.26', 
					'NOT11-P1'	=>	'2.496',		
					'NOT12-N1'	=>	'1.040', 
					'NOT12-P1'	=>	'0.520',					
					'NOT120-N1'	=>	'1.040',						
					'NOT120-P1'	=>	'2.496',					
					'NAND21-N1'  =>	'0.26',						
					'NAND21-N2'  =>	'0.26',						
					'NAND21-P1'  =>	'2.496',								
					'NAND21-P2'  =>	'0.52',	
					'NAND22-N1'  =>	'0.26',						
					'NAND22-N2'  =>	'0.26',						
					'NAND22-P1'  =>	'2.496',								
					'NAND22-P2'  =>	'2.496',
					'NAND23-N1'  =>	'1.612',						
					'NAND23-N2'  =>	'1.612',						
					'NAND23-P1'  =>	'0.52',										
					'NAND23-P2'  =>	'0.52',	
					'NAND24-N1'  =>	'1.612',					
					'NAND24-N2'  =>	'1.612',					
					'NAND24-P1'  =>	'2.496',								
					'NAND24-P2'  =>	'0.52',	
					'NAND220-N1'  =>	'1.612',
					'NAND220-N2'  =>	'1.612',
					'NAND220-P1'  =>	'2.496',
					'NAND220-P2'  =>	'2.496',					
					'NAND31-N1'  =>	'0.26',						
					'NAND31-N2'  =>	'0.26',						
					'NAND31-N3'  =>	'0.26',						
					'NAND31-P1'  =>	'2.496',								
					'NAND31-P2'  =>	'0.52',		
					'NAND31-P3'  =>	'0.52',
					'NAND32-N1'  =>	'0.26',						
					'NAND32-N2'  =>	'0.26',						
					'NAND32-N3'  =>	'0.26',						
					'NAND32-P1'  =>	'2.496',								
					'NAND32-P2'  =>	'2.496',
					'NAND32-P3'  =>	'0.52',						
					'NAND33-N1'  =>	'0.26',						
					'NAND33-N2'  =>	'0.26',						
					'NAND33-N3'  =>	'0.26',						
					'NAND33-P1'  =>	'2.496',								
					'NAND33-P2'  =>	'2.496',
					'NAND33-P3'  =>	'2.496',
					'NAND34-N1'  =>	'2.131',						
					'NAND34-N2'  =>	'2.132',						
					'NAND34-N3'  =>	'2.132',						
					'NAND34-P1'  =>	'0.52',										
					'NAND34-P2'  =>	'0.52',		
					'NAND34-P3'  =>	'0.52',				
					'NAND35-N1'  =>	'2.132',						
					'NAND35-N2'  =>	'2.132',						
					'NAND35-N3'  =>	'2.132',						
					'NAND35-P1'  =>	'2.496',								
					'NAND35-P2'  =>	'0.52',	
					'NAND35-P3'  =>	'0.52',				
					'NAND36-N1'  =>	'2.132',					
					'NAND36-N2'  =>	'2.132',					
					'NAND36-N3'  =>	'2.132',					
					'NAND36-P1'  =>	'2.496',								
					'NAND36-P2'  =>	'2.496',
					'NAND36-P3'  =>	'0.52',	
					'NAND320-N1'  =>	'2.132',
					'NAND320-N2'  =>	'2.132',
					'NAND320-N3'  =>	'2.132',
					'NAND320-P1'  =>	'2.496',
					'NAND320-P2'  =>	'2.496',
					'NAND320-P3'  =>	'2.496',					
					'NAND41-N1'  =>	'0.26',						
					'NAND41-N2'  =>	'0.26',						
					'NAND41-N3'  =>	'0.26',						
					'NAND41-N4'  =>	'0.26',						
					'NAND41-P1'  =>	'2.496',								
					'NAND41-P2'  =>	'0.52',		
					'NAND41-P3'  =>	'0.52',
					'NAND41-P4'  =>	'0.52',					
					'NAND42-N1'  =>	'0.26',						
					'NAND42-N2'  =>	'0.26',						
					'NAND42-N3'  =>	'0.26',						
					'NAND42-N4'  =>	'0.26',						
					'NAND42-P1'  =>	'2.496',								
					'NAND42-P2'  =>	'2.496',
					'NAND42-P3'  =>	'0.52',
					'NAND42-P4'  =>	'0.52',					
					'NAND43-N1'  =>	'0.26',						
					'NAND43-N2'  =>	'0.26',						
					'NAND43-N3'  =>	'0.26',						
					'NAND43-N4'  =>	'0.26',						
					'NAND43-P1'  =>	'2.496',								
					'NAND43-P2'  =>	'2.496',		
					'NAND43-P3'  =>	'2.496',
					'NAND43-P4'  =>	'0.52',					
					'NAND44-N1'  =>	'0.26',						
					'NAND44-N2'  =>	'0.26',						
					'NAND44-N3'  =>	'0.26',						
					'NAND44-N4'  =>	'0.26',						
					'NAND44-P1'  =>	'2.496',
					'NAND44-P2'  =>	'2.496',
					'NAND44-P3'  =>	'2.496',
					'NAND44-P4'  =>	'2.496',
					'NAND45-N1'  =>	'2.652',					
					'NAND45-N2'  =>	'2.652',
					'NAND45-N3'  =>	'2.652',
					'NAND45-N4'  =>	'2.652',
					'NAND45-P1'  =>	'0.52',										
					'NAND45-P2'  =>	'0.52',		
					'NAND45-P3'  =>	'0.52',
					'NAND45-P4'  =>	'0.52',					
					'NAND46-N1'  =>	'2.652',
					'NAND46-N2'  =>	'2.652',
					'NAND46-N3'  =>	'2.652',
					'NAND46-N4'  =>	'2.652',
					'NAND46-P1'  =>	'2.496',								
					'NAND46-P2'  =>	'0.52',		
					'NAND46-P3'  =>	'0.52',
					'NAND46-P4'  =>	'0.52',					
					'NAND47-N1'  =>	'2.652',
					'NAND47-N2'  =>	'2.652',
					'NAND47-N3'  =>	'2.652',
					'NAND47-N4'  =>	'2.652',
					'NAND47-P1'  =>	'2.496',								
					'NAND47-P2'  =>	'2.496',
					'NAND47-P3'  =>	'0.52',
					'NAND47-P4'  =>	'0.52',					
					'NAND48-N1'  =>	'2.652',
					'NAND48-N2'  =>	'2.652',
					'NAND48-N3'  =>	'2.652',
					'NAND48-N4'  =>	'2.652',
					'NAND48-P1'  =>	'2.496',								
					'NAND48-P2'  =>	'2.496',								
					'NAND48-P3'  =>	'2.496',								
					'NAND48-P4'  =>	'0.52',	
					'NAND420-N1'  =>	'2.652',
					'NAND420-N2'  =>	'2.652',
					'NAND420-N3'  =>	'2.652',
					'NAND420-N4'  =>	'2.652',
					'NAND420-P1'  =>	'2.496',
					'NAND420-P2'  =>	'2.496'	,			
					'NAND420-P3'  =>	'2.496'	,								
					'NAND420-P4'  =>	'2.496',					
					'NOR21-N1'  =>	'1.04',						
					'NOR21-N2'  =>	'0.26',						
					'NOR21-P1'  =>	'0.52',										
					'NOR21-P2'  =>	'0.52',
					'NOR22-N1'  =>	'1.04',						
					'NOR22-N2'  =>	'1.04',						
					'NOR22-P1'  =>	'0.52',										
					'NOR22-P2'  =>	'0.52',	
					'NOR23-N1'  =>	'0.26',						
					'NOR23-N2'  =>	'0.26',						
					'NOR23-P1'  =>	'4.576',									
					'NOR23-P2'  =>	'4.576',
					'NOR24-N1'  =>	'1.04',						
					'NOR24-N2'  =>	'0.26',						
					'NOR24-P1'  =>	'4.576',									
					'NOR24-P2'  =>	'4.576',	
					'NOR220-N1'  =>	'1.04',						
					'NOR220-N2'  =>	'1.04',						
					'NOR220-P1'  =>	'4.576',									
					'NOR220-P2'  =>	'4.576',						
					'NOR31-N1'  =>	'1.04',						
					'NOR31-N2'  =>	'0.26',						
					'NOR31-N3'  =>	'0.26',						
					'NOR31-P1'  =>	'0.52',										
					'NOR31-P2'  =>	'0.52',		
					'NOR31-P3'  =>	'0.52',
					'NOR32-N1'  =>	'1.04',						
					'NOR32-N2'  =>	'1.04',						
					'NOR32-N3'  =>	'0.26',						
					'NOR32-P1'  =>	'0.52',										
					'NOR32-P2'  =>	'0.52',		
					'NOR32-P3'  =>	'0.52',					
					'NOR33-N1'  =>	'1.04',						
					'NOR33-N2'  =>	'1.04',						
					'NOR33-N3'  =>	'1.04',						
					'NOR33-P1'  =>	'0.52',										
					'NOR33-P2'  =>	'0.52',		
					'NOR33-P3'  =>	'0.52',					
					'NOR34-N1'  =>	'0.26',						
					'NOR34-N2'  =>	'0.26',						
					'NOR34-N3'  =>	'0.26',						
					'NOR34-P1'  =>	'6.448',									
					'NOR34-P2'  =>	'6.448',
					'NOR34-P3'  =>	'6.448',
					'NOR35-N1'  =>	'1.04',						
					'NOR35-N2'  =>	'0.26',						
					'NOR35-N3'  =>	'0.26',						
					'NOR35-P1'  =>	'6.448',
					'NOR35-P2'  =>	'6.448',
					'NOR35-P3'  =>	'6.448',
					'NOR36-N1'  =>	'1.04',						
					'NOR36-N2'  =>	'1.04',						
					'NOR36-N3'  =>	'0.26',						
					'NOR36-P1'  =>	'6.448',
					'NOR36-P2'  =>	'6.448',
					'NOR36-P3'  =>	'6.448',
					'NOR320-N1'  =>	'1.04',							
					'NOR320-N2'  =>	'1.04',							
					'NOR320-N3'  =>	'1.04',							
					'NOR320-P1'  =>	'6.448',									
					'NOR320-P2'  =>	'6.448',	
					'NOR320-P3'  =>	'6.448',					
					'NOR41-N1'  =>	'1.04',						
					'NOR41-N2'  =>	'0.26',						
					'NOR41-N3'  =>	'0.26',						
					'NOR41-N4'  =>	'0.26',						
					'NOR41-P1'  =>	'0.52',										
					'NOR41-P2'  =>	'0.52',		
					'NOR41-P3'  =>	'0.52',
					'NOR41-P4'  =>	'0.52',					
					'NOR42-N1'  =>	'1.04',						
					'NOR42-N2'  =>	'1.04',						
					'NOR42-N3'  =>	'0.26',						
					'NOR42-N4'  =>	'0.26',						
					'NOR42-P1'  =>	'0.52',										
					'NOR42-P2'  =>	'0.52',		
					'NOR42-P3'  =>	'0.52',
					'NOR42-P4'  =>	'0.52',											
					'NOR43-N1'  =>	'1.04',						
					'NOR43-N2'  =>	'1.04',						
					'NOR43-N3'  =>	'1.04',						
					'NOR43-N4'  =>	'0.26',						
					'NOR43-P1'  =>	'0.52',										
					'NOR43-P2'  =>	'0.52',		
					'NOR43-P3'  =>	'0.52',
					'NOR43-P4'  =>	'0.52',					
					'NOR44-N1'  =>	'1.04',						
					'NOR44-N2'  =>	'1.04',						
					'NOR44-N3'  =>	'1.04',						
					'NOR44-N4'  =>	'1.04',						
					'NOR44-P1'  =>	'0.52',										
					'NOR44-P2'  =>	'0.52',		
					'NOR44-P3'  =>	'0.52',
					'NOR44-P4'  =>	'0.52',					
					'NOR45-N1'  =>	'0.26',						
					'NOR45-N2'  =>	'0.26',						
					'NOR45-N3'  =>	'0.26',						
					'NOR45-N4'  =>	'0.26',						
					'NOR45-P1'  =>	'7.8',										
					'NOR45-P2'  =>	'7.8',										
					'NOR45-P3'  =>	'7.8',										
					'NOR45-P4'  =>	'7.8',										
					'NOR46-N1'  =>	'1.04',						
					'NOR46-N2'  =>	'0.26',						
					'NOR46-N3'  =>	'0.26',						
					'NOR46-N4'  =>	'0.26',						
					'NOR46-P1'  =>	'7.8',										
					'NOR46-P2'  =>	'7.8',		
					'NOR46-P3'  =>	'7.8',
					'NOR46-P4'  =>	'7.8',					
					'NOR47-N1'  =>	'1.04',							
					'NOR47-N2'  =>	'1.04',							
					'NOR47-N3'  =>	'0.26',						
					'NOR47-N4'  =>	'0.26',						
					'NOR47-P1'  =>	'7.8',											
					'NOR47-P2'  =>	'7.8',			
					'NOR47-P3'  =>	'7.8',
					'NOR47-P4'  =>	'7.8',						
					'NOR48-N1'  =>	'1.04',							
					'NOR48-N2'  =>	'1.04',							
					'NOR48-N3'  =>	'1.04',							
					'NOR48-N4'  =>	'0.26',						
					'NOR48-P1'  =>	'7.8',											
					'NOR48-P2'  =>	'7.8',			
					'NOR48-P3'  =>	'7.8',
					'NOR48-P4'  =>	'7.8',										
					'NOR420-N1'  =>	'1.04',							
					'NOR420-N2'  =>	'1.04',							
					'NOR420-N3'  =>	'1.04',							
					'NOR420-N4'  =>	'1.04',							
					'NOR420-P1'  =>	'7.8',											
					'NOR420-P2'  =>	'7.8',			
					'NOR420-P3'  =>	'7.8',
					'NOR420-P4'  =>	'7.8',										
			);
}	

			



$flag = 0;


# $inputFile = fileparse($inputFile, ".fault");
#print "Input file = $inputFile \n";
#print "inputFile = $inputFile \n"; 
#$outputFile_O = $inputFile."-stats.txt";

$benchFile = "$inputFile.bench";
print "\n\tReading Bench File $benchFile \n\n";

my $start_time = [Time::HiRes::gettimeofday()];
#-----------------------------------------------------

readBenchFile();
readFaultsFile();
findEquivFaults();
# exit; 

#####################################################
# Retrieve the sa0 and sa1 probabilities of gate
%circuitFaults_0 = %{retrieve($inputFile."_sa0.prob")};
%circuitFaults_1 = %{retrieve($inputFile."_sa1.prob")};

$sum = 0;
@inter_IO_Gates = nsort @inter_IO_Gates;

foreach $gate (nsort keys %circuitFaults_0) {	
	if ( (grep {$_ eq $gate} @primaryInputs) or $gate =~ m/>/ ) {
		next;
	}
	else {	
		$s = $circuitFaults_0{$gate}/$numberOfTestVectors + $circuitFaults_1{$gate}/$numberOfTestVectors;
		# print "$gate: sa0 = ",$circuitFaults_0{$gate}/$numberOfTestVectors,", sa1 = ",$circuitFaults_1{$gate}/$numberOfTestVectors,", S = $s\n";
		$sum += $s;
	}
}

open (SAT, ">sat.log") or die $!;
print SAT $sum;
close(SAT);
print "\n$inputFile: SUM: $sum\n";

# selectionAlgorithmWithPOFSUpdate_ONLY($threshold);